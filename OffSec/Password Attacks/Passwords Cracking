
--- Passwords Cracking ---

• How Attackers Recover Weak Passwords
• Detection of Indicators and Telemetry
• Response Playbook


-- How Attackers Recover Weak Passwords --

Attackers don't usually try to "break" the encryption itself because that would take far too long with modern cryptography. Instead, they focus on guessing the password that protects the file. The two most common ways of doing this are dictionary attacks and brute-force (or mask) attacks.

• Dictionary Attacks
• Mask Attacks

➜ Dictionary Attacks

In a dictionary attack, the attacker uses a predefined list of potential passwords, known as a wordlist, and tests each one until the correct password is found. 
These wordlists often contain leaked passwords from previous breaches, common substitutions like password123, predictable combinations of names and dates, and other patterns that people frequently use. 
Because many users choose weak or common passwords, dictionary attacks are usually fast and highly effective.

➜ Mask Attacks

Brute-force and mask attacks go one step further. A brute-force attack systematically tries every possible combination of characters until it finds the right one. 
While this guarantees success eventually, the time it takes grows exponentially with the length and complexity of the password.

Mask attacks aim to reduce that time by limiting guesses to a specific format. For example, trying all combinations of three lowercase letters followed by two digits.

By narrowing the search space, mask attacks strike a balance between speed and thoroughness, especially when the attacker has some idea of how the password might be structured.

Practical tips attackers use (and defenders should know about):

• Start with a wordlist (fast wins). Common lists: rockyou.txt, common-passwords.txt.
• If the wordlist fails, move to targeted wordlists (company names, project names, or data from the target).
• If that fails, try mask or incremental attacks on short passwords (e.g. ?l?l?l?d?d = three lowercase letters + two digits, which is used as a password mask format by password cracking tools).
• Use GPU-accelerated cracking when possible; it dramatically speeds up attacks for some algorithms.
• Keep an eye on resource use: cracking is CPU/GPU intensive. That behaviour can be detected on a monitored endpoint.


If it's a PDF, proceed with PDF tools. If it's a ZIP, proceed with ZIP tools.

ubuntu@tryhackme:~/Desktop$ file flag.pdf
ubuntu@tryhackme:~/Desktop$ file flag.zip

• PDF: pdfcrack, john (via pdf2john)
• ZIP: fcrackzip, john (via zip2john)
• General: john (very flexible) and hashcat (GPU acceleration, more advanced)

ubuntu@tryhackme:~/Desktop$ pdfcrack -f flag.pdf -w /usr/share/wordlists/rockyou.txt 

ubuntu@tryhackme:~/Desktop$ zip2john flag.zip > ziphash.txt                                
ubuntu@tryhackme:~/Desktop$ john --wordlist=/usr/share/wordlists/rockyou.txt ziphash.txt


-- Detection of Indicators and Telemetry --

Offline cracking does not hit login services, so lockouts and failed logon dashboards stay quiet. We can detect the work where it runs, on endpoints and jump boxes. The important signals to monitor include:

• Process creation
• GPU and Resource Artefacts
• Network Hints, Light but Useful
• Unusual File Reads
• Detections


➜ Process creation: Password cracking has a small set of well-known binaries and command patterns that we can look out for. A mix of process events, file activity, GPU signals, and network touches tied to tooling and wordlists. Our goal is to make the activity obvious without drowning in noise.

• Binaries and aliases: john, hashcat, fcrackzip, pdfcrack, zip2john, pdf2john.pl, 7z, qpdf, unzip, 7za, perl invoking pdf2john.pl.
• Command‑line traits: --wordlist, -w, --rules, --mask, -a 3, -m in Hashcat, references to rockyou.txt, SecLists, zip2john, pdf2john.
• Potfiles and state: ~/.john/john.pot, .hashcat/hashcat.potfile, john.rec.

➜ GPU and Resource Artefacts

GPU cracking is loud. Sudden high utilisation on hosts can be picked up and would need to be investigated.

• nvidia-smi shows long‑running processes named hashcat or john.
• High, steady GPU utilisation and power draw while the fan curve spikes.
• Libraries loaded: nvcuda.dll, OpenCL.dll, libcuda.so, amdocl64.dll.

➜ Network Hints, Light but Useful

Offline cracking does not need the network once wordlists are present. Yet most operators fetch lists and tools first.

• Downloads of large text files named rockyou.txt, or Git clones of popular wordlist repos.
• Package installs, for example apt install john hashcat, detected by EDR package telemetry.
• Tool updates and driver fetches for GPU runtimes.

➜ Unusual File Reads

Repeated reads of files such as wordlists or encrypted files would need analysis.

➜ Detections

Some examples of detection rules and hunting queries we can put to use across various environments.

⇒ Sysmon:

(ProcessName="C:\Program Files\john\john.exe" OR ProcessName="C:\Tools\hashcat\hashcat.exe" OR CommandLine="*pdf2john.pl*" OR CommandLine="*zip2john*")

⇒ Linux audit rules, temporary for an investigation:

auditctl -w /usr/share/wordlists/rockyou.txt -p r -k wordlists_read
auditctl -a always,exit -F arch=b64 -S execve -F exe=/usr/bin/john -k crack_exec
auditctl -a always,exit -F arch=b64 -S execve -F exe=/usr/bin/hashcat -k crack_exec

⇒ Sigma style rule, Windows process create for cracking tools:

title: Password Cracking Tools Execution
id: 9f2f4d3e-4c16-4b0a-bb3a-7b1c6c001234
status: experimental
logsource:
  product: windows
  category: process_creation
detection:
  selection_name:
    Image|endswith:
      - '\john.exe'
      - '\hashcat.exe'
      - '\fcrackzip.exe'
      - '\pdfcrack.exe'
      - '\7z.exe'
      - '\qpdf.exe'
  selection_cmd:
    CommandLine|contains:
      - '--wordlist'
      - 'rockyou.txt'
      - 'zip2john'
      - 'pdf2john'
      - '--mask'
      - ' -a 3'
  condition: selection_name or selection_cmd
level: medium


-- Response Playbook --

1. Isolate the host if malicious activity is detected. If it is a lab, tag and suppress.
2. Capture triage artefacts such as process list, process memory dump, nvidia-smi sample output, open files, and the encrypted file.
3. Preserve the working directory, wordlists, hash files, and shell history.
4. Review which files were decrypted. Search for follow‑on access, lateral movement or exfiltration.
5. Identify the origin and intent of the activity. Was this authorised? If not, escalate to the IR team.
6. Remediate the activity, rotate affected keys and passwords, and enforce MFA for accounts.
7. Close with education and correct placement of tools into approved sandboxes.


*
