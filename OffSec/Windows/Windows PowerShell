
--- PowerShell ---

• What Is PowerShell
• PowerShell Basics
• Navigating the File System and Working with Files
• Piping, Filtering, and Sorting Data
• System and Network Information
• Real-Time System Analysis
• Scripting


-- What Is PowerShell --

PowerShell is a powerful tool from Microsoft designed for task automation and configuration management. It combines a command-line interface and a scripting language built on the .NET framework. 
Unlike older text-based command-line tools, PowerShell is object-oriented, which means it can handle complex data types and interact with system components more effectively. 
Initially exclusive to Windows, PowerShell has lately expanded to support macOS and Linux, making it a versatile option for IT professionals across different operating systems.

➜ A Brief History of PowerShell

PowerShell was developed to overcome the limitations of existing command-line tools and scripting environments in Windows. 
In the early 2000s, as Windows was increasingly used in complex enterprise environments, traditional tools like cmd.exe and batch files fell short in automating and managing these systems. 
Microsoft needed a tool that could handle more sophisticated administrative tasks and interact with Windows’ modern APIs.

Jeffrey Snover, a Microsoft engineer, realised that Windows and Unix handled system operations differently—Windows used structured data and APIs, while Unix treated everything as text files. 
This difference made porting Unix tools to Windows impractical. Snover’s solution was to develop an object-oriented approach, combining scripting simplicity with the power of the .NET framework. 
Released in 2006, PowerShell allowed administrators to automate tasks more effectively by manipulating objects, offering deeper integration with Windows systems.

As IT environments evolved to include various operating systems, the need for a versatile automation tool grew. In 2016, Microsoft responded by releasing PowerShell Core, an open-source and cross-platform version that runs on Windows, macOS, and Linux.

➜ The Power in PowerShell

To fully grasp the power of PowerShell, we first need to understand what an object is in this context.

In programming, an object represents an item with properties (characteristics) and methods (actions). For example, a car object might have properties like Color, Model, and FuelLevel, and methods like Drive(), HonkHorn(), and Refuel().

Similarly, in PowerShell, objects are fundamental units that encapsulate data and functionality, making it easier to manage and manipulate information. 
An object in PowerShell can contain file names, usernames or sizes as data (properties), and carry functions (methods) such as copying a file or stopping a process.

The traditional Command Shell’s basic commands are text-based, meaning they process and output data as plain text. Instead, when a cmdlet (pronounced command-let) is run in PowerShell, it returns objects that retain their properties and methods. 
This allows for more powerful and flexible data manipulation since these objects do not require additional parsing of text.


-- PowerShell Basics --

• Launching PowerShell
• Basic Syntax: Verb-Noun
• Basic Cmdlets
• Where to Find and Download Cmdlets

➜ Launching PowerShell

PowerShell can be launched in several ways, depending on your needs and environment. If you are working on a Windows system from the graphical interface (GUI), these are some of the possible ways to launch it:

• Start Menu: Type powershell in the Windows Start Menu search bar, then click on Windows PowerShell or PowerShell from the results.
• Run Dialog: Press Win + R to open the Run dialog, type powershell, and hit Enter.
• File Explorer: Navigate to any folder, then type powershell in the address bar, and press Enter. This opens PowerShell in that specific directory.
• Task Manager: Open the Task Manager, go to File > Run new task, type powershell, and press Enter.

Alternatively, PowerShell can be launched from a Command Prompt (cmd.exe) by typing powershell, and pressing Enter.

captain@THEBLACKPEARL C:\Users\captain>powershell

➜ Basic Syntax: Verb-Noun

PowerShell commands are known as cmdlets (pronounced command-lets)

Cmdlets follow a consistent Verb-Noun naming convention. This structure makes it easy to understand what each cmdlet does. The Verb describes the action, and the Noun specifies the object on which action is performed. 

• Get-Content: Retrieves (gets) the content of a file and displays it in the console.
• Set-Location: Changes (sets) the current working directory.

➜ Basic Cmdlets

To list all available cmdlets, functions, aliases, and scripts that can be executed in the current PowerShell session, we can use Get-Command. It’s an essential tool for discovering what commands one can use.

For each CommandInfo object retrieved by the cmdlet, some essential information (properties) is displayed on the console. It’s possible to filter the list of commands based on displayed property values. 
For example, if we want to display only the available commands of type “function”, we can use -CommandType "Function".

Another essential cmdlet to keep in our tool belt is Get-Help: it provides detailed information about cmdlets, including usage, parameters, and examples. It’s the go-to cmdlet for learning how to use PowerShell commands.

PowerShell includes aliases —which are shortcuts or alternative names for cmdlets— for many traditional Windows commands. Indispensable for users already familiar with other command-line tools, Get-Alias lists all aliases available. 
For example, dir is an alias for Get-ChildItem, and cd is an alias for Set-Location.

PS C:\Users\captain> Get-Command
PS C:\Users\captain> Get-Command -Name Remove*
PS C:\Users\captain> Get-Command -CommandType "Function"
PS C:\Users\captain> Get-Help Get-Date

PS C:\Users\captain> Get-Help Set-NetFirewallRule
PS C:\Users\captain> Get-Help Set-NetFirewallRule -Examples
PS C:\Users\captain> Get-Help Set-NetFirewallRule -Detailed
PS C:\Users\captain> Get-Help Set-NetFirewallRule -Full
PS C:\Users\captain> Get-Help Set-NetFirewallRule -Detailed
PS C:\Users\captain> Get-Help Set-NetFirewallRule -Online
 
PS C:\Users\captain> Get-Alias

➜ Where to Find and Download Cmdlets

Another powerful feature of PowerShell is the possibility of extending its functionality by downloading additional cmdlets from online repositories.

NOTE: Please note that the cmdlets listed in this section require a working internet connection to query online repositories. 

To search for modules (collections of cmdlets) in online repositories like the PowerShell Gallery, we can use Find-Module. Sometimes, if we don’t know the exact name of the module, it can be useful to search for modules with a similar name.
We can achieve this by filtering the Name property and appending a wildcard (*) to the module’s partial name, using the following standard PowerShell syntax: Cmdlet -Property "pattern*".

Once identified, the modules can be downloaded and installed from the repository with Install-Module, making new cmdlets contained in the module available for use.

PS C:\Users\captain> Find-Module -Name "PowerShell*"   
PS C:\Users\captain> Install-Module -Name "PowerShellGet"


-- Navigating the File System and Working with Files --

PowerShell provides a range of cmdlets for navigating the file system and managing files, many of which have counterparts in the traditional Windows CLI.

Get-ChildItem lists the files and directories in a location specified with the -Path parameter. If no Path is specified, the cmdlet will display the content of the current working directory.

To navigate to a different directory, we can use the Set-Location cmdlet.

To create an item in PowerShell, we can use New-Item. We will need to specify the path of the item and its type (whether it is a file or a directory). The Remove-Item cmdlet removes both directories and files.

We can copy or move files and directories alike, using respectively Copy-Item (equivalent to copy) and Move-Item (equivalent to move).

To read and display the contents of a file, we can use the Get-Content cmdlet, which works similarly to the type command in Command Prompt (or cat in Unix-like systems).

PS C:\Users\captain> Get-ChildItem 
PS C:\Users\captain\Documents> Get-ChildItem -Path ".\captain-cabin\"
PS C:\Users\captain> Set-Location -Path ".\Documents"

PS C:\Users\captain\Documents> New-Item -Path ".\captain-cabin\captain-wardrobe" -ItemType "Directory"
PS C:\Users\captain\Documents> New-Item -Path ".\captain-cabin\captain-wardrobe\captain-boots.txt" -ItemType "File"     

PS C:\Users\captain\Documents> Remove-Item -Path ".\captain-cabin\captain-wardrobe"
PS C:\Users\captain\Documents> Remove-Item -Path ".\captain-cabin\captain-wardrobe\captain-boots.txt"
 
PS C:\Users\captain\Documents> Copy-Item -Path .\captain-cabin\captain-hat.txt -Destination .\captain-cabin\captain-hat2.txt
PS C:\Users\captain\Documents\captain-cabin> Get-Content -Path ".\captain-hat.txt"


-- Piping, Filtering, and Sorting Data --

Piping is a technique used in command-line environments that allows the output of one command to be used as the input for another. This creates a sequence of operations where the data flows from one command to the next. 
Represented by the | symbol, piping is widely used in the Windows CLI, as introduced earlier in this module, as well as in Unix-based shells.

For example, if you want to get a list of files in a directory and then sort them by size, you could use the following command in PowerShell: Get-ChildItem | Sort-Object Length

Beyond sorting, PowerShell provides a set of cmdlets that, when combined with piping, allow for advanced data manipulation and analysis.

To filter objects based on specified conditions, returning only those that meet the criteria, we can use the Where-Object cmdlet. For instance, to list only .txt files: Get-ChildItem | Where-Object -Property "Extension" -eq ".txt"

• -ne: "not equal". This operator can be used to exclude objects from the results based on specified criteria.
• -gt: "greater than". This operator will filter only objects which exceed a specified value. It is important to note that this is a strict comparison, meaning that objects that are equal to the specified value will be excluded from the results.
• -ge: "greater than or equal to". This is the non-strict version of the previous operator. A combination of -gt and -eq.
• -lt: "less than". Like its counterpart, "greater than", this is a strict operator. It will include only objects which are strictly below a certain value.
• -le: "less than or equal to". Just like its counterpart -ge, this is the non-strict version of the previous operator. A combination of -lt and -eq.

Objects can also be filtered by selecting properties that match (-like) a specified pattern: Get-ChildItem | Where-Object -Property "Name" -like "ship*" 

Select specific properties from objects or limit the number of objects returned. It’s useful for refining the output to show only the details one needs: Get-ChildItem | Select-Object Name,Length

Select-String cmdlet searches for text patterns within files, similar to grep in Unix-based systems or findstr in Windows Command Prompt: Select-String -Path ".\captain-hat.txt" -Pattern "hat"

The Select-String cmdlet fully supports the use of regular expressions (regex). This advanced feature allows for complex pattern matching within files, making it a powerful tool for searching and analysing text data.

PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Sort-Object Length
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Where-Object -Property "Extension" -eq ".txt" 
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Where-Object -Property "Name" -like "ship*"  
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Where-Object Length -GT 100

PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Select-Object Name,Length 
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Sort-Object Length -Descending
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Sort-Object Length -Descending | Select-Object -First 1
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Select-Object -First 1
PS C:\Users\captain\Documents\captain-cabin> Get-ChildItem | Select-Object Name,Length -Last 1

PS C:\Users\captain\Documents\captain-cabin> Select-String -Path ".\captain-hat.txt" -Pattern "hat" 


-- System and Network Information --

The Get-ComputerInfo cmdlet retrieves comprehensive system information, including operating system information, hardware specifications, BIOS details, and more. 

Get-LocalUser lists all the local user accounts on the system. The default output displays, for each user, username, account status, and description.

Get-NetIPConfiguration provides detailed information about the network interfaces on the system, including IP addresses, DNS servers, and gateway configurations.

In case we need specific details about the IP addresses assigned to the network interfaces, the Get-NetIPAddress cmdlet will show details for all IP addresses configured on the system, including those that are not currently active.

PS C:\Users\captain> Get-ComputerInfo
PS C:\Users\captain> Get-LocalUser
PS C:\Users\captain> Get-NetIPConfiguration
PS C:\Users\captain> Get-NetIPAddress


-- Real-Time System Analysis --

Get-Process provides a detailed view of all currently running processes, including CPU and memory usage, making it a powerful tool for monitoring and troubleshooting.

Get-Service allows the retrieval of information about the status of services on the machine, such as which services are running, stopped, or paused.

To monitor active network connections, Get-NetTCPConnection displays current TCP connections, giving insights into both local and remote endpoints. 
This cmdlet is particularly handy during an incident response or malware analysis task, as it can uncover hidden backdoors or established connections towards an attacker-controlled server.

Get-FileHash is a useful cmdlet generating file hashes, which is particularly valuable in incident response, threat hunting, and malware analysis, as it helps verify file integrity and detect potential tampering.

You can also view the Alternate Data Streams (ADS) attached to a file through PowerShell

PS C:\Users\Alex\Documents> Get-Item -Path "C:\House\house_log.txt" -Stream *

PSPath        : Microsoft.PowerShell.Core\FileSystem::C:\House\house_log.txt::$DATA
PSParentPath  : Microsoft.PowerShell.Core\FileSystem::C:\House
PSChildName   : house_log.txt::$DATA
PSDrive       : C
PSProvider    : Microsoft.PowerShell.Core\FileSystem
PSIsContainer : False
FileName      : C:\House\house_log.txt
Stream        : :$DATA
Length        : 13

PSPath        : Microsoft.PowerShell.Core\FileSystem::C:\House\house_log.txt:housinginfo
PSParentPath  : Microsoft.PowerShell.Core\FileSystem::C:\House
PSChildName   : house_log.txt:housinginfo
PSDrive       : C
PSProvider    : Microsoft.PowerShell.Core\FileSystem
PSIsContainer : False
FileName      : C:\House\house_log.txt
Stream        : housinginfo
Length        : 21

In the output above, you can see two streams that are attached to the file C:\House\house_log.txt:

• :$DATA is the default data stream of every NTFS file. It contains the normal file contents and is not an ADS.
• housinginginfo is the Alternate Data Stream (ADS) added to this file. It appears as house_log.txt:housinginfo, which means an extra hidden stream named housinginfo is attached to this file.

PS C:\Users\captain> Get-Process
PS C:\Users\captain> Get-Service
PS C:\Users\captain> Get-Service | Where-Object Status -eq Running 
PS C:\Users\captain> Get-NetTCPConnection

PS C:\Users\captain\Documents\captain-cabin> Get-FileHash -Path .\ship-flag.txt    
PS C:\Users\Alex\Documents> Get-Item -Path "C:\House\house_log.txt" -Stream *


-- Scripting --

Scripting is the process of writing and executing a series of commands contained in a text file, known as a script, to automate tasks that one would generally perform manually in a shell, like PowerShell.

Simply speaking, scripting is like giving a computer a to-do list, where each line in the script is a task that the computer will carry out automatically. 
This saves time, reduces the chance of errors, and allows to perform tasks that are too complex or tedious to do manually

Invoke-Command is essential for executing commands on remote systems, making it fundamental for system administrators, security engineers and penetration testers. 
Invoke-Command enables efficient remote management and—combining it with scripting—automation of tasks across multiple machines. 
It can also be used to execute payloads or commands on target systems during an engagement by penetration testers—or attackers alike.


PS C:\Users\captain> Get-Help Invoke-Command -examples
PS C:\Users\captain> Invoke-Command -ComputerName RoyalFortune -ScriptBlock { Get-Service }

➜ Invoke-Command Examples

Invoke-Command -FilePath c:\scripts\test.ps1 -ComputerName Server01

Invoke-Command -ComputerName Server01 -Credential Domain01\User01 -ScriptBlock {
    Get-Culture
}

$s = New-PSSession -ComputerName Server02 -Credential Domain01\User01
Invoke-Command -Session $s -ScriptBlock { Get-Culture }

Invoke-Command -ComputerName Server02 -ScriptBlock { $p = Get-Process PowerShell }
Invoke-Command -ComputerName Server02 -ScriptBlock { $p.VirtualMemorySize }
$s = New-PSSession -ComputerName Server02
Invoke-Command -Session $s -ScriptBlock { $p = Get-Process PowerShell }
Invoke-Command -Session $s -ScriptBlock { $p.VirtualMemorySize }

$command = {
    Get-EventLog -LogName 'Windows PowerShell' |
        Where-Object { $_.Message -like '*certificate*' }
}
Invoke-Command -ComputerName S1, S2 -ScriptBlock $command

$parameters = @{
  ComputerName      = 'Server01', 'Server02', 'TST-0143', 'localhost'
  ConfigurationName = 'MySession.PowerShell'
  ScriptBlock       = { Get-EventLog 'Windows PowerShell' }
}
Invoke-Command @parameters

$version = Invoke-Command -ComputerName (Get-Content Machines.txt) -ScriptBlock {
    (Get-Host).Version
}

$s = New-PSSession -ComputerName Server01, Server02
Invoke-Command -Session $s -ScriptBlock { Get-EventLog system } -AsJob
$j = Get-Job
$j | Format-List -Property *
$results = $j | Receive-Job

$Log = 'Windows PowerShell'
Invoke-Command -ComputerName Server01 -ScriptBlock {
    Get-EventLog -LogName $Using:Log -Newest 10
}

Invoke-Command -ComputerName S1, S2 -ScriptBlock { Get-Process PowerShell }
Invoke-Command -ComputerName S1, S2 -HideComputerName -ScriptBlock {
    Get-Process PowerShell
}

$parameters = @{
    ComputerName = 'Server01'
    ScriptBlock  = {
        Param ($param1, $param2)
        Get-ChildItem -Name $param1 -Include $param2
    }
    ArgumentList = 'a*', '*.pdf'
}
Invoke-Command @parameters

$parameters = @{
    ComputerName = 'Server01'
    ScriptBlock  = { Get-ChildItem $args[0] $args[1] }
    ArgumentList = 'C:\Test', '*.txt*'
}
Invoke-Command @parameters

$parameters = @{
    ComputerName = (Get-Content Servers.txt)
    FilePath     = 'C:\Scripts\Sample.ps1'
    ArgumentList = 'Process', 'Service'
}
Invoke-Command @parameters

$LiveCred = Get-Credential
$parameters = @{
  ConfigurationName = 'Microsoft.Exchange'
  ConnectionUri     = 'https://ps.exchangelabs.com/PowerShell'
  Credential        = $LiveCred
  Authentication    = 'Basic'
  ScriptBlock       = { Set-Mailbox Dan -DisplayName 'Dan Park' }
}
Invoke-Command @parameters

$so = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
$parameters = @{
    ComputerName  = 'server01'
    UseSSL        = $true
    ScriptBlock   = { Get-HotFix }
    SessionOption = $so
    Credential    = 'server01\user01'
}
Invoke-Command @parameters

$max = New-PSSessionOption -MaximumRedirection 1
$parameters = @{
  ConnectionUri    = 'https://ps.exchangelabs.com/PowerShell'
  ScriptBlock      = { Get-Mailbox dan }
  AllowRedirection = $true
  SessionOption    = $max
}
Invoke-Command @parameters

Enable-WSManCredSSP -Role Client -DelegateComputer Server02
$s = New-PSSession Server02
Invoke-Command -Session $s -ScriptBlock { Enable-WSManCredSSP -Role Server -Force }
$parameters = @{
  Session        = $s
  ScriptBlock    = { Get-Item \\Net03\Scripts\LogFiles.ps1 }
  Authentication = 'CredSSP'
  Credential     = 'Domain01\Admin01'
}
Invoke-Command @parameters

$parameters = @{
  ComputerName          = (Get-Content -Path C:\Test\Servers.txt)
  InDisconnectedSession = $true
  FilePath              = '\\Scripts\Public\ConfigInventory.ps1'
  SessionOption         = @{
      OutputBufferingMode = 'Drop'
      IdleTimeout         = [timespan]::FromHours(12)
  }
}
Invoke-Command @parameters





•
➜ 
⇒
->
►


Install / Launch
--------------------

Windows (winget):
winget search Microsoft.PowerShell
winget install --id Microsoft.PowerShell --source winget

Linux (Ubuntu): sudo snap install powershell --classic

macOS: 
brew install powershell/tap/powershell
PSVersionTable


Get Help & Discover Commands
-------------------------------

Get-Help Get-Help
Get-Help Get-Process
Get-Help Get-Service
Get-Command
Get-Help -Name Get-Command -Detailed
Update-Help


Aliases
-----------
cd, mkdir, del


Files & Folders
-------------------

Get-ChildItem
Set-Location .\Documents\
New-Item file.txt
New-Item -ItemType Directory logs
Remove-Item .\logs\
Copy-Item file.txt file1.txt
Move-Item .\file1.txt ..\Desktop\
Get-Content .\file.txt


Processes & Services
------------------------

Get-Process
Get-Process -Name win*
Stop-Process -Id 5432

Get-Service
Start-Service -Name Appinfo
Stop-Service -Name Appinfo

Get-Process | Sort CPU -Descending | Select -First 20


Filtering / Piping
----------------------

Get-Process | Select-Object ProcessName, Id
Get-Service | Where-Object Status -eq "Running"
Select-String -Pattern "today" .\file.txt


Local Users & Groups
------------------------

Get-LocalUser
New-LocalUser -Name "j.doe" -Password (ConvertTo-SecureString 'password123' -AsPlainText -Force)
Set-LocalUser -Name "j.doe" -Description "Test user"
Disable-LocalUser -Name "j.doe"
Enable-LocalUser -Name "j.doe"
Remove-LocalUser -Name "j.doe"

Get-LocalGroup
New-LocalGroup -Name "Students"
Set-LocalGroup -Name "Students" -Description "Improvise. Adapt. Overcome."
Add-LocalGroupMember -Group "Students" -Member "j.doe"
Remove-LocalGroupMember -Group "Students" -Member "j.doe"
Remove-LocalGroup -Name "Students"


Active Directory (RSAT/AD module)
-------------------------------------

Get-ADUser "j.doe"
Get-ADUser -Filter *
New-ADUser -Name "j.doe" -SamAccountName j.doe -AccountPassword (ConvertTo-SecureString "sifre123!" -AsPlainText -Force)
Set-ADUser -Identity "j.doe" -Surname "Doe"
Remove-ADUser "j.doe"

Get-ADGroup "Students"
Get-ADGroup -Filter *
New-ADGroup -Name "Students" -GroupScope Universal
Set-ADGroup -Identity "Students" -Description "Learn as if you were to live forever"
Get-ADGroupMember -Identity "Students"
Add-ADGroupMember -Identity "Students" -Members j.doe
Remove-ADGroupMember -Identity "Students" -Member "j.doe"
Remove-ADGroup "Students"


Networking
--------------

Get-NetIPAddress
ipconfig
netstat -ano
nslookup example.com
arp -a
Test-NetConnection
Invoke-WebRequest -Uri "https://upload.wikimedia.org/wikipedia/commons/a/af/PowerShell_Core_6.0_icon.png" -OutFile "powershell.png"


System / Info / Hashes
---------------------------

Get-ComputerInfo
Get-ComputerInfo | Select-Object WindowsVersion

Get-WmiObject -Class win32_OperatingSystem
Get-Hotfix
Get-Service | Where-Object DisplayName -like '*Defender*'
Get-ChildItem -Recurse *.* | Select-String -Pattern "SEARCH_STR"

Get-Acl file.txt
Get-Acl -Path "C:\junk\"

Get-FileHash file.txt
Get-FileHash -Algorithm MD5 file.txt
Get-FileHash -Algorithm SHA1 file.txt
Get-FileHash -Algorithm SHA256 file.txt
Get-FileHash -Algorithm SHA512 file.txt


Scripting Basics
---------------------

# Variables
$name = "John Doe"
$age = 30
$firstName, $lastName = "John", "Doe"

# If / Else
if ($age -gt 18) { Write-Host "Adult" } else { Write-Host "Kid" }

# Switch
$dayOfWeek = Get-Date -Format dddd
switch ($dayOfWeek) {
  "Monday" { "Start the week!" }
  "Friday" { "Almost weekend!" }
  Default { "Carry on." }
}

# Loops
for ($i=1; $i -le 10; $i++) { Write-Host $i }

$i=1
while ($i -le 10) { Write-Host $i; $i++ }

$i=1
do { Write-Host $i; $i++ } while ($i -le 10)

$names = "John","Jane","Doe"
foreach ($name in $names) { Write-Host $name }


Incident Examples
---------------------

Get-Process | Sort CPU -Descending | Select -First 20
Get-NetTCPConnection | Sort-Object -Property State
Get-ScheduledTask | Where {$_.State -ne 'Disabled'}
Get-Service | Where-Object {$_.Status -eq 'Running'}
Get-WinEvent -FilterHashtable @{LogName='Security'; StartTime=(Get-Date).AddHours(-1)} -MaxEvents 200
Get-FileHash C:\temp\susp.exe -Algorithm SHA256


